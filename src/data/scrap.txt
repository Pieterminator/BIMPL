
stack run trans MNone PropGGC data\test.txt PropEng data\output.txt
stack run trans MOptimize PropGGC data\test.txt PropEng data\output.txt
stack run trans MSimplify PropGGC data\test.txt PropEng data\output.txt
stack run trans MStatistics PropGGC data\test.txt PropEng data\output.txt

stack run trans MNone PropGGC ..\utils\data\rg-formulas.tmp PropEng data\output.txt
stack run trans MSimplify PropGGC ..\utils\data\rg-formulas.tmp PropEng data\output.txt

stack run trans MOptSen PropGGC data\test.txt PropEng ..\utils\data\rule-output.tmp
stack run trans MOptSen PropGGC ..\utils\data\rule-formulas.tmp PropEng data\output.txt

stack run trans MOptForm PropGGC data\test.txt PropEng data\output.txt
stack run trans MOptForm PropGGC "..\utils\data\Test BIMPL 2\rg-formulas.tmp" PropEng "data\output.txt"

stack run trans MStatistics PropGGC "..\utils\data\Test BIMPL 1\rule-formulas.tmp" PropEng "..\utils\data\Test BIMPL 1\statistics\rule-formulas.csv"

stack run trans "~ Cube ( p ) | ( Cube ( q ) & Cube ( p ) )"

Cube ( a ) | ( ~ Cube ( a ) $ ~ Cube ( b ) )


PConj COr (PConj CAnd (PAtom (AKind Tet (IVar (VString "a")))) (PAtom (AKind Tet (IVar (VString "e"))))) (PConj CAnd (PAtom (AKind Tet (IVar (VString "a")))) (PConj CAnd (PAtom (AKind Tet (IVar (VString "f")))) (PNeg (PConj CAnd (PAtom (AKind Tet (IVar (VString "a")))) (PConj CAnd (PAtom (AKind Tet (IVar (VString "e")))) (PAtom (AKind Tet (IVar (VString "f")))))))))
PConj CAnd (PAtom (AKind Tet (IVar (VString "a")))) (PConj CAnd (PConj COr (PAtom (AKind Tet (IVar (VString "f")))) (PAtom (AKind Tet (IVar (VString "e"))))) (PImpl (PConj CAnd (PConj CAnd (PAtom (AKind Tet (IVar (VString "a")))) (PAtom (AKind Tet (IVar (VString "e"))))) (PAtom (AKind Tet (IVar (VString "f"))))) (PAtom (AKind Tet (IVar (VString "e"))))))

¬ ∨ ∧ → ⇔
base
Cube ( p ) % Cube ( q )

biconditional 1
( Cube ( p ) $ Cube ( q ) ) & ( Cube ( q ) $ Cube ( p ) )

biconditional 2
( ~ Cube ( p ) & ~ Cube ( q ) ) | ( Cube ( p ) & Cube ( q ) )

exclusive disjunction
( Cube ( p ) | Cube ( q ) ) & ~ ( Cube ( p ) & Cube ( q ) )

redundance 1
Cube ( p ) | ( Cube ( p ) & Cube ( q ) )
redundance 2
Cube ( p ) & ( Cube ( p ) | Cube ( q ) )
redundance 5
Cube ( p ) % ( Cube ( p ) & Cube ( q ) )

( Cube ( p ) $ Cube ( q ) ) $ Cube ( p )
Cube ( p ) $ ( Cube ( p ) $ Cube ( q ) )



circularity
( ( Cube ( p ) $ Cube ( q ) ) & ( Cube ( q ) $ Cube ( r ) ) ) & ( Cube ( r ) $ Cube ( p ) )
( ( ( Cube ( p ) $ Cube ( q ) ) & ( Cube ( q ) $ Cube ( r ) ) ) & ( Cube ( r ) $ Cube ( s ) ) ) & ( Cube ( s ) $ Cube ( p ) )

circular redundance
( ( Cube ( p ) % Cube ( q ) ) & ( Cube ( q ) % Cube ( r ) ) ) & ( Cube ( r ) % Cube ( p ) )





( Cube ( p ) % Cube ( q ) ) $ Cube ( p )

( Cube ( p ) & ( Cube ( s ) $ Cube ( q ) ) ) & Cube ( r ) 

Problematic formula (probably because of max search depth)
( Cube ( r ) & ( ( Cube ( p ) $ Cube ( q ) ) | ( Cube ( q ) $ Cube ( p ) ) ) ) % Cube ( r )